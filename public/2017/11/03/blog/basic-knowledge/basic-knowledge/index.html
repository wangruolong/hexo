<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前端基础知识。记录了在前端领域遇到的一些问题，以及解决这些问题的过程和方法。还有自己对一些知识概念的理解和领悟。">
<meta name="keywords" content="前端基础">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础技能">
<meta property="og:url" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/index.html">
<meta property="og:site_name" content="大大白的个人博客">
<meta property="og:description" content="前端基础知识。记录了在前端领域遇到的一些问题，以及解决这些问题的过程和方法。还有自己对一些知识概念的理解和领悟。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/未装propTypes报错1.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/未装propTypes报错2.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/未开启modules.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/开启modules.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/获取ip.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/presets没有设置stage-2.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/未exclude导致的babel报错.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/原型与原型链.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/shuffle算法.jpg">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/九宫格.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/lifecycle.png">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/lifecycle1.jpg">
<meta property="og:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/lifecycle2.jpg">
<meta property="og:updated_time" content="2020-05-10T09:31:25.007Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端基础技能">
<meta name="twitter:description" content="前端基础知识。记录了在前端领域遇到的一些问题，以及解决这些问题的过程和方法。还有自己对一些知识概念的理解和领悟。">
<meta name="twitter:image" content="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/未装propTypes报错1.png">






  <link rel="canonical" href="https://ruolong.wang/2017/11/03/blog/basic-knowledge/basic-knowledge/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>前端基础技能 | 大大白的个人博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大大白的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">人生就像一场旅行，身体和灵魂总有一个要在路上！</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/blog/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/blog/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/blog/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/blog/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-works1">
    <a href="/blog/works1/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>H5小游戏1</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-works2">
    <a href="/blog/works2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>H5小游戏2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-fiction">
    <a href="/blog/fiction/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>大将军归来</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/blog/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ruolong.wang/blog/2017/11/03/blog/basic-knowledge/basic-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大大白">
      <meta itemprop="description" content="沉淀下来的东西，才是真正属于自己的财富！">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大大白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端基础技能
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-03 12:00:00" itemprop="dateCreated datePublished" datetime="2017-11-03T12:00:00+08:00">2017-11-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-10 17:31:25" itemprop="dateModified" datetime="2020-05-10T17:31:25+08:00">2020-05-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/WEB前端/" itemprop="url" rel="index"><span itemprop="name">WEB前端</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/WEB前端/基础知识/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前端基础知识。记录了在前端领域遇到的一些问题，以及解决这些问题的过程和方法。还有自己对一些知识概念的理解和领悟。</p>
<a id="more"></a>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h3><p>未装propTypes报错Cannot read property ‘array’ of undefined<br>react15之后prop-types被剥离开来，而react-router里面的很多写法还是react.proptypes这样肯定报错。所以有两种方案，一种是把react降到15之前（不包括15），另外一种就是把react-router升级到3.x以上版本。<br>为什么不直接升级到4.x因为我试用了一下发现是服务端渲染，而且一大堆配套的都要升级，因此升级到3.x是最明智的选择。<br><img src="未装propTypes报错1.png"><br><img src="未装propTypes报错2.png"></p>
<h3 id="Redux-Saga"><a href="#Redux-Saga" class="headerlink" title="Redux Saga"></a>Redux Saga</h3><p>当我dispatch一个action后，这个先发到reducer。然后才走到saga，saga拿到后put了一个新的action这个新的action才是我们要处理的。<br>简单来说，当我们dispatch一个action后，先发到reducer，然后saga同时也收到了一份，这时候saga可以put出新的action给reducer接收。<br>换句话来说，saga是监听redux总线上的数据，原来怎么dispatch还是按照原来的走，当saga监听到action后可以自己做一些处理然后put出新的action。<br>循环事件，后来的事件把前面的覆盖<code>takeLast</code><br>并发请求。有时候有些操作需要发起多个请求，这样一个操作的时间就需要time1+time2+time3。但是，如果这些请求没有先后关系就可以一次性发出请求，这样做的好处就是这个操作的时间只会是最长的那个请求的时间。比如原来的时间是100ms+200ms+150ms，现在就只要200ms。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> call(api1,api2,api3)</span><br></pre></td></tr></table></figure></p>
<p>顺序执行和并行执行。在saga中有些操作需要互相调用方法。<code>yield put(action1)</code>是异步的，<code>yield* sagaFun1()</code>同步的。可以根据实际情况结合使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发执行</span></span><br><span class="line"><span class="keyword">yield</span> put(action1)</span><br><span class="line"><span class="keyword">yield</span> put(action2)</span><br><span class="line"><span class="keyword">yield</span> put(action3)</span><br><span class="line"><span class="comment">// 顺序执行</span></span><br><span class="line"><span class="keyword">yield</span>* sagaFun1()</span><br><span class="line"><span class="keyword">yield</span>* sagaFun2()</span><br><span class="line"><span class="keyword">yield</span>* sagaFun3()</span><br></pre></td></tr></table></figure></p>
<h3 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h3><h4 id="合理使用Container和Dump"><a href="#合理使用Container和Dump" class="headerlink" title="合理使用Container和Dump"></a>合理使用Container和Dump</h4><p>有些组件的数据都是从父组件一直传递到子组件，这样当父组件渲染的时候，子组件也会跟着渲染。所以比如list，dialog等类型的组件应该是在redux里面，然后container进行connect。只有这些变化的时候才会重新render，否则父组件重新render也不会让子组件重新render因为，子组件的props都没有变化。<br>定制shouldComponentUpdate函数<br>shouldComponentUpdate(nextProps,nextState) false不render，true才render。如果啥也不反悔默认返回true。在最新的react中，react给我们提供了React.PureComponent，官方也在早期提供了名为react-addons-pure-render-mixin插件来重新实现shouldComponentUpdate生命周期方法。<br>immutable与with-immutable-props-to-js<br>建议使用seamless-immutable。javascript中的对象一般都是可变的，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新对象将影响到原始对象。这样做非常的昂贵，对cpu和内存会造成浪费。可以用withImmutablePropsToJs再包一层，保证在组件拿到的props后是同一个对象，只要对比值就可以了。</p>
<h4 id="针对React的diff算法加入key，防止最坏情况的发生"><a href="#针对React的diff算法加入key，防止最坏情况的发生" class="headerlink" title="针对React的diff算法加入key，防止最坏情况的发生"></a>针对React的diff算法加入key，防止最坏情况的发生</h4><p>react为了追求高性能，采用了时间复杂度为O(N)来比较两个属性结构的区别。传统的比较两个树形结构，需要通过O(N^3)，这样性能很低。<br>两个节点不一样最坏时间复杂度。O(N)的最坏时间复杂度。也就是说避免这种情况：把<code>&lt;div&gt;&lt;Text1 /&gt;&lt;Text2 /&gt;&lt;/div&gt;</code>改成<code>&lt;div&gt;&lt;Text2 /&gt;&lt;Text1 /&gt;&lt;/div&gt;</code>，react在对比的时候发现Text1和Text2不是同一个组件然后就直接销毁了，再重新生成，但是事实上他们只是换了一下顺序而已。<br>两个节点一样但是顺序不一样，同样也会导致最坏时间复杂度。这种情况要避免其实很简单，就是加入唯一key，这样react就会根据key的变化，而不是根据顺序进行diff计算了。<br>设置key不能用index，举一个例子：<br>注意：以下例子是反例，需要说明几个正确的结论<br>列表最好要加key<br>不能用index作为key<br>最好使用id作为key<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Example2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">		<span class="keyword">super</span>(props)</span><br><span class="line">		<span class="keyword">this</span>.state=&#123;</span><br><span class="line">			data:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      data:[<span class="string">'d'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    		&#123;</span></span><br><span class="line"><span class="xml">    			this.state.data.map((val,idx)=&gt;<span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span> <span class="attr">parentValue</span>=<span class="string">&#123;val&#125;</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">    		&#125;</span></span><br><span class="line"><span class="xml">    		<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span>改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReactEmptyComponent空组件<br>ReactTextComponent文本组件<br>ReactDOMComponent浏览器组件<br>ReactCompositeComponent自定义组件<br>上面实例中在数组重新排序后，key对应的实例都没有销毁，而是重新更新。具体更新过程我们拿key=0的元素来说明， 数组重新排序后：<br>首先，state改变肯定会引起重新render。组件重新render后得到新的虚拟dom；<br>新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；<br>然后比较其children，子组件有两个，一个是文本组件ReactTextComponent，另一个是浏览器的input组件ReactDOMComponent<br>文本组件是受控组件，值变化了，重新render，重新赋值。<br>input组件是非受控组件，由于父组件重新render了所以自己也重新render，但是并没有重新赋值。<br>这里需要说几个事情<br>input是非受控组件，可以重新render但是它的值并没有改变<br>key=0的组件并没有销毁，而是进行了diff比较<br>重新render和重新赋值是两个概念。<br>受控和非受控最好不好互相转换。<br>把受控组件转成非受控组件，会导致受控在某处就断开了。<br>把非受控组件转成非空组件，并且在willReceive判断进行setState以此来达到受控的目的，会导致有时候外部一个改变直接导致了非受控组件的变化，把自己的值都清空了。<br>比如有几个组件<text1><text2>，把<code>&lt;div&gt;&lt;Text1 /&gt;&lt;Text2 /&gt;&lt;/div&gt;</code>改成<code>&lt;div&gt;&lt;Text2 /&gt;&lt;Text1 /&gt;&lt;/div&gt;</code>，如果没有加key，会导致<text1>和<text2>先销毁然后再重新生成。这样会很消耗性能。但是如果加了key<code>&lt;div&gt;&lt;Text1 key=1 /&gt;&lt;Text2 key=2 /&gt;&lt;/div&gt;</code>当变成了<code>&lt;div&gt;&lt;Text2 key=2 /&gt;&lt;Text1 key=1 /&gt;&lt;/div&gt;</code>react会知道不用销毁，只要调整一下顺序即可，也就是只要重新render执行更新的生命周期就行了，这样就减少了不必要的性能浪费。</text2></text1></text2></text1></p>
<h4 id="尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。"><a href="#尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。" class="headerlink" title="尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。"></a>尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</h4><p><code>onClick={this.handleClick}</code>构造函数每一次渲染的时候只会执行一遍；这种方法最好。这种写法初学者经常会遇到的一个问题就是undefined，这是因为没有使用箭头函数。普通函数中，this指向其函数的直接调用者；箭头函数中，this指向其定义环境，任何方法都改变不了其指向，如call（）、bind（）等；构造函数中，如果不使用new,则this指向window，如果使用new创建了一个实例，则this指向该实例。<br><code>onClick={this.handleClick.bind(this)}</code>在每次render()的时候都会重新执行一遍函数。<br><code>onClick={()=&gt;{this.handleClick()}}</code>每一次render()的时候，都会生成一个新的匿名函数，即使两个箭头函数的内容是一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;TodoItem text=<span class="string">"First"</span> complete=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">  &lt;TodoItem text=<span class="string">"Second"</span> complete=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ B</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">  &lt;TodoItem text="Zero" complete=&#123;false&#125; /</span>&gt;</span><br><span class="line">  &lt;TodoItem text=<span class="string">"First"</span> complete=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">  &lt;TodoItem text=<span class="string">"Second"</span> complete=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>合并和拆分。合并业务代码，拆分公共代码。splitChunks<br>图片优化。雪碧图。url-loader和file-loader配合使用。limit8k的图通过file-loader直接打入css里面。超过8K的再用url-loader加载。可以和雪碧图综合考虑。<br>压缩js和css。UglifyJsPlugin、OptimizeCSSAssetsPlugin<br>样式表用link引入，并置顶。</p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>样式表的Loader style-loader css-loader sass-loader<br>css-Loader把css通过<link>引入，而style-loader把css放到<styles>里面。<br>css-loader要配合MiniCssExtractPlugin.loader会把css进行抽取独立文件。<br>css-loader要启用modules=true，在代码里面才能import styles from ‘style.css’。才可以设置localIdentName规则，让css的名称唯一防止全名冲突。<br>可以开启OptimizeCSSAssetsPlugin对css进行压缩。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(sc|c)ss$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: <span class="literal">true</span>,</span><br><span class="line">        localIdentName: <span class="string">'[path][name]__[local]--[hash:base64:5]'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'sass-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></styles></p>
<p><img src="未开启modules.png"><br><img src="开启modules.png"></p>
<p>file-loader与url-loader<br>相同点：都可以用来加载资源文件。<br>不同点：url-loader可以设置小于指定大小的文件直接打包到js里面，减少请求次数。file-loader则是把文件加载到指定目录。<br>当有文件超过<code>url-loader</code>指定的文件大小后，不会被打包到js里面，但是它就变成需要<code>file-loader</code>加载否则会报错。<br>把小图片打包到js里面减少请求次数各有利弊。优点：可以减少小图片的请求次数，降低网络IO的请求次数。缺点：图片会被转换成base64的格式和js一起打包进入会带出新的问题，就是这样会导致css变大，这样加载单个css可能需要的时长会更长。另外，base64的算法是把原来的数据每3位用4位替换，这样原来如果是1，就会变成4/3，相当于比原来大了1/3。<br>因此是否需要使用url-loader把小图片打包到js文件需要权衡后再做决定。把小图片打包到js需要做的牺牲就是js文件会变大。<br>file-loader实现的是懒加载，只有在页面需要用到具体的元素才会加载，否则并不会加载。这样能提高整体的性能。<br>file-loader的publicPath属性，用来指定访问的路径。<br>file-loader的outputPath属性，用来指定打包输出的路径和访问的路径。建议使用outputPath属性，因为这个属性同时指定了打包输入和访问的路径，而publicPath只指定了访问的路径，如果你实际打包的路径不是这个就访问不到了。<br>url-loader的limit属性，用来指定小于限定的字节(Byte)则打包到js文件里面，超过限定的字节(Byte)则需要file-loader加载。<br>基本用法如下，小于8k的图片可以转成base64一起打入css，大于的则用file-loader加载。这样既可以减少图片请求数，又保证了css文件不会太大。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.(jpg|png|svg|gif)/</span>,</span><br><span class="line">  use:[&#123;</span><br><span class="line">    loader:<span class="string">'url-loader'</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">      limit:<span class="number">8129</span>,<span class="comment">//小于limit限制8k 的图片将转为base64嵌入引用位置</span></span><br><span class="line">      fallback:<span class="string">'file-loader'</span>,<span class="comment">//大于limit限制的将转交给指定的loader处理</span></span><br><span class="line">      outputPath:<span class="string">'imgs/'</span><span class="comment">//options会直接传给fallback指定的loader</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>IP访问<br>在package.json的执行脚本中增加<code>--host 0.0.0.0</code>就可以通过ip访问了，缺点是刚开始启动的时候无法打开网页，需要等启动完成后输入地址重新访问。<br>也可以通过js获取本机ip<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// host: '0.0.0.0'</span></span><br><span class="line">  host:(<span class="function"><span class="keyword">function</span> <span class="title">getIPAdress</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> interfaces = <span class="built_in">require</span>(<span class="string">'os'</span>).networkInterfaces()  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> devName <span class="keyword">in</span> interfaces)&#123;  </span><br><span class="line">        <span class="keyword">var</span> iface = interfaces[devName]  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;iface.length;i++)&#123;  </span><br><span class="line">            <span class="keyword">var</span> alias = iface[i]</span><br><span class="line">            <span class="keyword">if</span>(alias.family === <span class="string">'IPv4'</span> &amp;&amp; alias.address !== <span class="string">'127.0.0.1'</span> &amp;&amp; !alias.internal)&#123;  </span><br><span class="line">              <span class="keyword">return</span> alias.address  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="获取ip.png"></p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><strong>dirname和process.cwd()<br>`</strong>dirname<code>是当前js文件所处的路径。</code>process.cwd()`是当前进程的工作目录，参照package.json所在的位置的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(<span class="string">'process.cwd()是当前进程的工作目录，参照package.json所在的位置的。'</span>,process.cwd())</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'__dirname是当前js文件所处的路径。'</span>,__dirname)</span><br></pre></td></tr></table></figure></p>
<p>path<br>要使用<code>path</code>需要先<code>npm install path</code>，然后再在需要的文件里面引入<code>const path = require(&#39;path&#39;);</code>才可以使用。<br>两种用法<br>连接路径：path.join([path1][, path2][, …])<br>路径解析：path.resolve([from …], to)<br>最大的区别：就是对<code>/</code>的解析，<code>join</code>只是拼上去，而<code>resolve</code>则是解析成根路径<code>/</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">path.join(<span class="string">'/foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz/asdf'</span>, <span class="string">'quux'</span>, <span class="string">'..'</span>)<span class="comment">// 连接后'/foo/bar/baz/asdf'</span></span><br><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz'</span>)<span class="comment">// 输出结果为'/foo/bar/baz'</span></span><br><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>)<span class="comment">// 输出结果为'/tmp/file'</span></span><br><span class="line">path.resolve(<span class="string">'wwwroot'</span>, <span class="string">'static_files/png/'</span>, <span class="string">'../gif/image.gif'</span>)<span class="comment">// 当前的工作路径是 /home/itbilu/node，则输出结果为'/home/itbilu/node/wwwroot/static_files/gif/image.gif'</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);<span class="comment">//D:\myProgram\test</span></span><br><span class="line"><span class="keyword">let</span> myPath = path.join(__dirname,<span class="string">'/img/so'</span>);<span class="comment">//D:\myProgram\test\img\so</span></span><br><span class="line"><span class="keyword">let</span> myPath2 = path.join(__dirname,<span class="string">'./img/so'</span>);<span class="comment">//D:\myProgram\test\img\so</span></span><br><span class="line"><span class="keyword">let</span> myPath3 = path.resolve(__dirname,<span class="string">'/img/so'</span>);<span class="comment">//D:\img\so</span></span><br><span class="line"><span class="keyword">let</span> myPath4 = path.resolve(__dirname,<span class="string">'./img/so'</span>);<span class="comment">//D:\myProgram\test\img\so</span></span><br></pre></td></tr></table></figure>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>presets<br>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。<br>最新转码规则<br>$ npm install –save-dev babel-preset-latest<br>react 转码规则<br>$ npm install –save-dev babel-preset-react<br>不同阶段语法提案的转码规则（共有4个阶段），选装一个<br>Stage 0 - Strawman（展示阶段）<br>Stage 1 - Proposal（征求意见阶段）<br>Stage 2 - Draft（草案阶段）<br>Stage 3 - Candidate（候选人阶段）<br>Stage 4 - Finished（定案阶段）<br>$ npm install –save-dev babel-preset-stage-0<br>$ npm install –save-dev babel-preset-stage-1<br>$ npm install –save-dev babel-preset-stage-2<br>$ npm install –save-dev babel-preset-stage-3<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"env"</span>,</span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果presets没有设置<code>stage-2</code>，因为这里面有些语法还在<code>stage-2</code>阶段还没有正式发布，所以如果没有加上这个配置就无法解析这种语法。<br><img src="presets没有设置stage-2.png"><br>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。<br>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站Github.com/tc39/ecma262查看。</p>
<p>在SwitchCase的case中如果没有{}<br>当词法声明 (let、const、function 和 class) 出现在 case或default 子句中。该词法声明的变量在整个 switch 语句块中是可见的，但是它只有在运行到它定义的 case 语句时，才会进行初始化操作。为了保证词法声明语句只在当前 case 语句中有效，需要用大括号{}将你子句包裹在块中。</p>
<h3 id="presets打包优化"><a href="#presets打包优化" class="headerlink" title="presets打包优化"></a>presets打包优化</h3><p>presets中已经包含了一组用来转换ES6+的语法的插件，如果只使用少数新特性而非大多数新特性，可以不使用preset而只使用对应的转换插件。</p>
<p>babel默认只转换语法（比如箭头函数、解构赋值、class等语法），而不转换新的API（比如Map，Set，Promise），如需使用新的API，还需要使用对应的转换插件或者polyfill。</p>
<p>使用babel-polyfill(不使用useBuiltIns)<br>优点：一次性解决所有兼容性问题,而且是全局的,浏览器的console也可以使用<br>缺点：一次性引入了ES6+的所有polyfill，打包后的js文件体积会偏大，对于现代的浏览器，有些不需要polyfill，造成流量浪费，污染了全局对象，不适合框架或库的开发。</p>
<p>使用babel-preset-env插件和useBuiltIns属性。我的理解是从字面上来看出发点是适配环境的问题，比如支持react的jsx语法，比如支持stage-2的语法（比如…语法），比如支持浏览器版本等跟环境相关的。<br>优点：按需(按照指定的浏览器环境所需)引入polyfill, 一定程度上减少了不必要polyfill的引入。<br>缺点：解决问题的角度不一样，主要是处理环境方面的适配，比如并没办法支持generate语法。</p>
<p>使用babel-plugins。主要用于针对某个特性需要的转义，比如支持写在class的属性transform-class-properties插件。支持import和export的add-module-exports插件。等等<br>优点：配置完一个转换插件后, 代码中每个使用这个API的地方的代码都会被转换成使用polyfill中实现的代码。作用域是模块,避免全局冲突。是按需引入,避免不必要引入造成及代码臃肿。<br>缺点：每个模块内单独引用和定义polyfill函数,造成了重复定义,使代码产生冗余。</p>
<p>使用插件 babel-runtime 与 babel-plugin-tranform-runtime。抽离了公共模块，避免了重复引入，从core.js的库中引入所需polyfill<br>简单来说，就是提供了比较多的通用的公共模块。其实也是一个插件。但是对[].includes(x), 依赖于Array.prototype.include仍无法使用。<br>优点：<br>无全局污染<br>依赖统一按需引入(polyfill是各个模块共享的), 无重复引入, 无多余引入<br>适合用来编写lib(第三方库)类型的代码<br>缺点：<br>被polyfill的对象是临时构造并被import/require的,并不是真正挂载到全局<br>由于不是全局生效, 对于实例化对象的方法,如[].include(x), 依赖于Array.prototype.include仍无法使用。因为这些在转换时并没办法被显示的检查出来。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>,&#123;</span><br><span class="line">      <span class="attr">"modules"</span>: <span class="literal">false</span>,<span class="comment">// 模块化交给webpack处理</span></span><br><span class="line">      <span class="attr">"useBuiltIns"</span>:<span class="string">"usage"</span>,<span class="comment">// "usage" | "entry" | false, defaults to false.</span></span><br><span class="line">      <span class="attr">"targets"</span>: &#123;<span class="attr">"browsers"</span>: [<span class="string">"safari &gt;= 7"</span>, <span class="string">"ie&gt;=8"</span>]&#125;<span class="comment">// 浏览器或者node环境</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"add-module-exports"</span>,<span class="comment">// 转义import和export</span></span><br><span class="line">    <span class="string">"transform-runtime"</span>,<span class="comment">// 转义generator</span></span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span>,<span class="comment">// 转义@</span></span><br><span class="line">    <span class="string">"transform-es3-member-expression-literals"</span>,<span class="comment">// 支持ie</span></span><br><span class="line">    <span class="string">"transform-es3-property-literals"</span>,<span class="comment">// 支持ie</span></span><br><span class="line">    [<span class="string">"transform-es2015-classes"</span>, &#123; <span class="attr">"loose"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="string">"transform-proto-to-assign"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否可以只用useBuiltIns+babel-polyfill不用transform-runtime？不行。一个典型的场景就是前者没有转义generator，后者有对静态的generator做转义。</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">env     useBuiltIns</span><br><span class="line">false   11165  907KB</span><br><span class="line">usage   8136   674KB</span><br><span class="line">entry   8136   674KB</span><br><span class="line"></span><br><span class="line">transform-runtime</span><br><span class="line">default 2119   168KB</span><br></pre></td></tr></table></figure>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"add-module-exports"</span>,<span class="comment">// 转义import和export</span></span><br><span class="line">    <span class="string">"transform-runtime"</span>,<span class="comment">// 转义generator</span></span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span>,<span class="comment">// 转义@</span></span><br><span class="line">    <span class="string">"transform-class-properties"</span>,<span class="comment">// 转义class</span></span><br><span class="line">    <span class="string">"transform-es3-member-expression-literals"</span>,<span class="comment">// 支持ie</span></span><br><span class="line">    <span class="string">"transform-es3-property-literals"</span><span class="comment">// 支持ie</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置add-module-exports<br>作用：支持import和export语法<br>安装：”babel-plugin-add-module-exports”: “^1.0.0”</p>
<p>配置transform-runtime<br>作用：支持generator。当项目启用generate的时候如果没有这个插件会报错regeneratorRuntime is not defined。<br>安装：”babel-plugin-transform-runtime”: “^6.23.0”</p>
<p>配置transform-decorators-legacy<br>作用：支持@语法<br>安装：”babel-plugin-transform-decorators-legacy”: “^1.3.5”</p>
<p>配置transform-class-properties<br>作用：有时候我们将 defaultProps, propTypes写在class中，而不是写在class外面就可以使用这个插件支持。<br>安装：”babel-plugin-transform-class-properties”: “^6.24.1”</p>
<p>配置 transform-es3-member-expression-literals和transform-es3-property-literals<br>作用：兼容IE8</p>
<ul>
<li>安装：”babel-plugin-transform-es3-member-expression-literals”: “^6.22.0”和<br>“babel-plugin-transform-es3-property-literals”: “^6.22.0”</li>
</ul>
<p>像下面这种代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; &#125;</span><br><span class="line"><span class="built_in">module</span>.exports = _main2.default;</span><br></pre></td></tr></table></figure></p>
<p>在 IE8 下会直接报”缺少标识符、字符串或数字”的错。我们得在对象的属性上加 ‘’ 才可以。就像下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="string">'default'</span>: obj &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于原因，并不是 IE8 下对象的属性必须得加 ‘’ 才行，而是 default 的问题，作为一个关键字，同样的问题还包括 catch。这两种情况，可以通过使用<code>transform-es3-property-literals</code>和<code>transform-es3-member-expression-literals</code>这两个插件搞定。总之，在平时写代码的时候避免使用关键字，或者保留字作为对象的属性值，尤其是在习惯不加引号的情况下。相关讨论：<a href="https://github.com/airbnb/javascript/issues/61" target="_blank" rel="noopener">Allow reserved words for properties</a></p>
<h3 id="babel在webpack中出现的问题"><a href="#babel在webpack中出现的问题" class="headerlink" title="babel在webpack中出现的问题"></a>babel在webpack中出现的问题</h3><p><code>Using removed Babel 5 option</code><br>使用了被移除的babel5中的语法，是因为没有把node_modules排除掉。目录是相对package.json的路径。<br>因为node_modules里面有一些包是用了Babel 5中的语法，但是在这个loader里面又是被移除了，所以就报错了，根本解决办法就是把<code>node_modules</code>exclude掉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">      loader: [<span class="string">'babel-loader'</span>,<span class="string">'eslint-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="未exclude导致的babel报错.png"></p>
<h2 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h2><p>package.json中需要引用的npm包<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"babel-eslint"</span>: <span class="string">"^10.0.1"</span>,</span><br><span class="line">  <span class="attr">"eslint"</span>: <span class="string">"^5.13.0"</span>,</span><br><span class="line">  <span class="attr">"eslint-plugin-react"</span>: <span class="string">"^7.12.4"</span>,</span><br><span class="line">  <span class="attr">"eslint-loader"</span>: <span class="string">"^2.1.1"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>eslintrc.json配置文件<br>要在配置文件中设置 parser 为 babel-eslint ，意思是用babel转换之后再给eslint验证，否则有些es6的语法可能eslint并无法识别。<br>babel-eslint eslint eslint-plugin-react主要用于eslintrc.json的配置。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"react"</span>],</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"commonjs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"es6"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"plugin:react/recommended"</span>],</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"react"</span>: &#123;</span><br><span class="line">      <span class="attr">"createClass"</span>: <span class="string">"createReactClass"</span>,</span><br><span class="line">      <span class="attr">"pragma"</span>: <span class="string">"React"</span>,</span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"detect"</span>,</span><br><span class="line">      <span class="attr">"flowVersion"</span>: <span class="string">"0.53"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"propWrapperFunctions"</span>: [</span><br><span class="line">      <span class="string">"forbidExtraProps"</span>,</span><br><span class="line">      &#123; <span class="attr">"property"</span>: <span class="string">"freeze"</span>, <span class="attr">"object"</span>: <span class="string">"Object"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"property"</span>: <span class="string">"myFavoriteWrapper"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"ecmaFeatures"</span>: &#123;</span><br><span class="line">      <span class="attr">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ecmaVersion"</span>: <span class="number">2018</span>,</span><br><span class="line">    <span class="attr">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"indent"</span>: [<span class="string">"error"</span>, <span class="string">"tab"</span>],</span><br><span class="line">    <span class="attr">"linebreak-style"</span>: [<span class="string">"error"</span>, <span class="string">"windows"</span>],<span class="comment">//注意，这里最好去掉，因为windows和UNIX系统的换行符是不一样的。</span></span><br><span class="line">    <span class="attr">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"single"</span>],</span><br><span class="line">    <span class="attr">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"never"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置到webpack中<br>eslint-loader用于webpack的配置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        loader: [<span class="string">'babel-loader'</span>,<span class="string">'eslint-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>增加钩子让用户在提交前都执行以下eslint。<br>Git hooks made easy<br>在package.json增加husky（哈士奇）依赖，同时配置commit之前和push之前需要执行的命令，强制用户执行eslint检查。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"pre-commit"</span>: <span class="string">"npm test"</span>,</span><br><span class="line">      <span class="attr">"pre-push"</span>: <span class="string">"npm test"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>:&#123;</span><br><span class="line">    <span class="attr">"husky"</span>: <span class="string">"^1.3.1"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>推荐配置<br>可以访问<code>https://cn.eslint.org/demo/</code>勾选需要的配置，然后下载到本地使用。<br>0 = off, 1 = warn, 2 = error<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123;</span><br><span class="line">      <span class="attr">"ecmaVersion"</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"script"</span>,</span><br><span class="line">      <span class="attr">"ecmaFeatures"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">      <span class="attr">"constructor-super"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-case-declarations"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-class-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-compare-neg-zero"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-cond-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-console"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-const-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-constant-condition"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-control-regex"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-debugger"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-delete-var"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-dupe-args"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-dupe-class-members"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-dupe-keys"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-duplicate-case"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-empty-character-class"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-empty-pattern"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-empty"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-ex-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-extra-boolean-cast"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-extra-semi"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-fallthrough"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-func-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-global-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-inner-declarations"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-invalid-regexp"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-irregular-whitespace"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-mixed-spaces-and-tabs"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-new-symbol"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-obj-calls"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-octal"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-redeclare"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-regex-spaces"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-self-assign"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-sparse-arrays"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-this-before-super"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-undef"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-unexpected-multiline"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-unreachable"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-unsafe-finally"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-unsafe-negation"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-unused-labels"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-unused-vars"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"no-useless-escape"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"require-yield"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"use-isnan"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"valid-typeof"</span>: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><h3 id="基本规范state-set-‘key’-value"><a href="#基本规范state-set-‘key’-value" class="headerlink" title="基本规范state.set(‘key’,value)"></a>基本规范state.set(‘key’,value)</h3><p>如果value是基础类型，比如number，string等，是可以直接这样set进去。<br>如果value是对象类型，比如map，list等，可以fromJS(value)再设置进去。<br>因为<code>state.set(&#39;key&#39;,fromJS(1))</code>和<code>state.set(&#39;key&#39;,1)</code>，在<code>state.get(&#39;key&#39;)</code>是一样的。但是，<code>state.set(&#39;key&#39;,fromJS({a:1}))</code>和<code>state.set(&#39;key&#39;,{a:1})</code>，在<code>state.get(&#39;key&#39;)</code>是不一样的。前者get出来的是一个immutable对象，后者get出来的是一个js对象。<br>所以综上所述，在set的时候，如果是基础类型可以直接set，如果是对象类型要先<code>fromJS()</code>再set进去。<br>以此类推<code>state.merge({&#39;key2&#39;,value2})</code>这个value也是一样的道理。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>不要在container里面toJS()，因为toJS()之后会是一个新的对象，导致react重新render。<br>可以配合<code>with-immutable-props-to-js</code>使用<code>const TodoListSmart = connect(mapStateToProps,mapDispatchToProps)(WithImmutablePropsToJs(TodoListDump))</code>。这样可以保证<code>TodoListDump</code>获取到的props如果是同一个值不会产生新的对象。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>客户端，发起HTTPS请求，请求服务端返回一个，非对称加密的公钥。</li>
<li>服务端，收到HTTPS请求，用私钥生成一个公钥，把公钥返回给客户端。</li>
<li>客户端，收到公钥，用公钥加密数据，把加密后的数据发给服务端。</li>
<li>服务端，收到加密的数据，用私钥解密，获得原文内容。</li>
</ol>
<h3 id="劫持"><a href="#劫持" class="headerlink" title="劫持"></a>劫持</h3><p>在上述基本流程中，如果客户端和服务端交互的过程中被拦截。就有可能出现问题。</p>
<ol>
<li>客户端，发起HTTPS请求，请求服务端返回一个，非对称加密的公钥。</li>
<li>服务端，收到HTTPS请求，用私钥生成一个公钥，把公钥返回给客户端。</li>
<li>第三方收到公钥，在自己这边用自己的私钥生成一个公钥，然后传递给客户端。</li>
<li>客户端，收到公钥，用公钥加密数据，把加密后的数据发给服务端。</li>
<li>第三方进行拦截，用自己的私钥解密客户端发送的数据，获得原文后用真正服务端的公钥进行加密，然后返回给服务端。</li>
<li>服务端，收到加密的数据，用私钥解密，获得原文内容。</li>
</ol>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>证书中包含了加密过的A公钥和权威机构的信息，所以服务器只需要给客户端下发数字证书即可。权威机构的公钥不需要传输，因为权威机构会和主流的浏览器或操作系统合作，将他们的公钥内置在浏览器或操作系统环境中。<br>服务器给客户端下发数字证书时证书被中间人劫持了，中间人将服务器的证书替换成自己的证书下发给客户端，客户端收到之后能够通过权威机构的公钥解密证书内容（因为中间人的证书也是权威机构私钥加密的），从而获取公钥，但是，这里的公钥并不是服务器原本的A公钥，而是中间人自己证书中的B公钥。</p>
<h3 id="安全传输证书"><a href="#安全传输证书" class="headerlink" title="安全传输证书"></a>安全传输证书</h3><p>保证客户端收到的证书是服务器下发的证书，没有被中间人篡改过。<br>检查证书中的域名和当前访问的域名是否一致</p>
<h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><p>原型与原型链，作用域及闭包，异步和单线程</p>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>创建对象有几种方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>:<span class="string">'o1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o11 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">'o1'</span>&#125;)</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">'o2'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M()</span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="keyword">var</span> P=&#123;<span class="attr">name</span>:<span class="string">'o3'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(P)</span><br></pre></td></tr></table></figure></p>
<p>构造函数<code>M</code>、原型对象<code>M.prototype</code>、实例<code>new M()</code>、原型链<code>__proto__</code><br>instanceof的原理。判断<code>实例对象</code>的<code>__proto__</code>是不是<code>原型对象</code><br>new运算符<br><img src="原型与原型链.png"></p>
<p>继承和重写<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让我们从一个自身拥有属性a和b的函数里创建一个对象o：</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这么写也一样</span></span><br><span class="line"><span class="comment">function f() &#123;</span></span><br><span class="line"><span class="comment">  this.a = 1;</span></span><br><span class="line"><span class="comment">  this.b = 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> f(); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在f函数的原型上定义属性</span></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要在 f 函数的原型上直接定义 f.prototype = &#123;b:3,c:4&#125;;这样会直接打破原型链</span></span><br><span class="line"><span class="comment">// o.[[Prototype]] 有属性 b 和 c</span></span><br><span class="line"><span class="comment">//  (其实就是 o.__proto__ 或者 o.constructor.prototype)</span></span><br><span class="line"><span class="comment">// o.[[Prototype]].[[Prototype]] 是 Object.prototype.</span></span><br><span class="line"><span class="comment">// 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null</span></span><br><span class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></span><br><span class="line"><span class="comment">// 根据定义，null 就是没有 [[Prototype]]。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上，整个原型链如下: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为 2</span></span><br><span class="line"><span class="comment">// 原型上也有一个'b'属性，但是它不会被访问到。</span></span><br><span class="line"><span class="comment">// 这种情况被称为"属性遮蔽 (property shadowing)"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// c是o的自身属性吗？不是，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// c是o.[[Prototype]]的属性吗？是的，该属性的值为 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// d 是 o 的自身属性吗？不是，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// o.[[Prototype]].[[Prototype]] 为 null，停止搜索</span></span><br><span class="line"><span class="comment">// 找不到 d 属性，返回 undefined</span></span><br></pre></td></tr></table></figure></p>
<p>this指向<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.m()); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 当调用 o.m 时，'this' 指向了 o.</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line"><span class="comment">// p是一个继承自 o 的对象</span></span><br><span class="line">p.a = <span class="number">4</span>; <span class="comment">// 创建 p 的自身属性 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.m()); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 调用 p.m 时，'this' 指向了 p</span></span><br><span class="line"><span class="comment">// 又因为 p 继承了 o 的 m 函数</span></span><br><span class="line"><span class="comment">// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a'</span></span><br></pre></td></tr></table></figure></p>
<p>原型链性能<br>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>
<p>错误实践：扩展原生对象的原型<br>经常使用的一个错误实践是扩展 Object.prototype 或其他内置原型。<br>这种技术被称为猴子补丁并且会破坏封装。尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。<br>扩展内置原型的唯一理由是支持 JavaScript 引擎的新特性，如 Array.forEach。</p>
<h3 id="作用域及闭包"><a href="#作用域及闭包" class="headerlink" title="作用域及闭包"></a>作用域及闭包</h3><p>闭包是函数和声明该函数的词法环境的组合。换句话说说就是，函数和声明该函数的词法环境。<br>词法作用域。词法作用域中<code>有效范围</code>，是变量在代码中<code>声明的位置</code>所决定的。嵌套的函数可以访问在其外部声明的变量。<br>闭包。JavaScript中的函数会形成闭包。 闭包是由<code>函数</code>以及<code>创建该函数的词法环境</code>组合而成。这个环境包含了这个闭包创建时所能访问的<code>所有局部变量</code>。<br>它们共享相同的函数定义，但是保存了不同的词法环境。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p>
<p>词法环境。let块作用域，var完整作用域</p>
<h3 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h3><p>Event Loop事件运行机制<br>简单来说，主要从执行栈、宏任务队列、微任务队列三个维度去描述。<br>setTimeout等是宏任务，promise等是微任务。<br>执行栈，顺序执行js每一行代码，遇到异步代码则插入到任务队列。特别注意new Promise是同步代码，只不过它的callback是异步的应该是把它的callback放入微队列。<br>优先级，同步的普通代码&gt;微队列&gt;宏队列。执行顺序按照优先级从高到低执行，每一级执行完了才能执行下一级。<br>微任务或者宏任务执行过程如果还有产生新的任务，则继续插入到任务队列后面。微队列有上限1000行。</p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>push(v)修改原数组，返回数组长度。<br>pop()修改原数组，返回最后一个对象。<br>shift()修改原数组，返回第一个对象。<br>unshift(v)修改原数组，返回数组长度。<br>堆（Heap）。unshift在数组头部插入。堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。堆是线性数据结构，相当于一维数组，有唯一后继。<br>栈（Stack）。push()在数组末尾插入，pop()在数组末尾删除并返回。栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。栈是只能在某一端插入和删除的特殊线性表。<br>队列（Queue）。push()在数组末尾插入，shift()在数组头部删除并返回。特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）</p>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。<br>MacroTask（宏任务）。script全部代码、setTimeout、setInterval、I/O、UI Rendering。<br>MicroTask（微任务）。Promise、process.nextTick (Node独有)、Object.observe、MutationObserver</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>执行栈每次扫描js代码，只剥离一层，然后<code>优先执行同步的代码，异步的代码分别放入宏队列和微队列</code>。<br>在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。<br>当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的，拿NodeJS中的微任务process.nextTick()来说，它的上限是1000个。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="开始执行"><a href="#开始执行" class="headerlink" title="开始执行"></a>开始执行</h5><p>step1<br>mainStack=[console.log(1)]<br>macroQueue=[]<br>microQueue=[]<br>打印结果<br>1</p>
<p>step2<br>mainStack=[setTimeout]<br>macroQueue=[callback1]<br>microQueue=[]<br>打印结果<br>1</p>
<p>step3<br>mainStack=[promise]<br>macroQueue=[callback1]<br>microQueue=[callback2]<br>打印结果<br>1<br>4</p>
<p>step4<br>mainStack=[setTimeout]<br>macroQueue=[callback1,callback3]<br>microQueue=[callback2]<br>打印结果<br>1<br>4</p>
<p>step5<br>mainStack=[console]<br>macroQueue=[callback1,callback3]<br>microQueue=[callback2]<br>打印结果<br>1<br>4<br>7</p>
<h5 id="全局Script代码执行完了，进入下一个步骤，从microtask-queue中依次取出任务执行，直到microtask-queue队列为空。"><a href="#全局Script代码执行完了，进入下一个步骤，从microtask-queue中依次取出任务执行，直到microtask-queue队列为空。" class="headerlink" title="全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。"></a>全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。</h5><p>step6<br>mainStack=[callback2]<br>macroQueue=[callback1,callback3]<br>microQueue=[]<br>打印结果<br>1<br>4<br>7<br>5</p>
<p>step7（这一步执行callback1的时候又遇到了另一个Promise，Promise异步执行完后在microtask queue中又注册了一个callback4回调函数）<br>mainStack=[callback1]<br>macroQueue=[callback3]<br>microQueue=[]<br>打印结果<br>1<br>4<br>7<br>5<br>2</p>
<p>step8<br>mainStack=[promise]<br>macroQueue=[callback3]<br>microQueue=[callback4]<br>打印结果<br>1<br>4<br>7<br>5<br>2</p>
<p>step9<br>mainStack=[callback4]<br>macroQueue=[callback3]<br>microQueue=[]<br>打印结果<br>1<br>4<br>7<br>5<br>2<br>3</p>
<p>step10<br>mainStack=[callback3]<br>macroQueue=[]<br>microQueue=[]<br>打印结果<br>1<br>4<br>7<br>5<br>2<br>3<br>6</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果<br>1<br>4<br>10<br>5<br>6<br>7<br>2<br>3<br>9<br>8</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>常用用法，exec，test，match。<br>test比较简单，返回表达式是否匹配上了字符串。匹配上了返回true，没匹配上返回false。<br>exec和match作用类似，不同的地方在于前者是字符串作为表达式的参数，后者是表达式作为字符串的参数。<br>还有就是正则表达式结合replace，可以使用子表达式来达到更灵活的替换规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`console.log('123123')`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(console.log\(')(\S+)('\))/</span></span><br><span class="line"><span class="keyword">let</span> execRes = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(execRes)</span><br><span class="line"><span class="keyword">let</span> testRes = reg.test(str)</span><br><span class="line"><span class="built_in">console</span>.log(testRes)</span><br><span class="line"><span class="keyword">let</span> matchRes = str.match(reg)</span><br><span class="line"><span class="built_in">console</span>.log(matchRes)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line">str = str.replace(<span class="regexp">/(console.log\(')(.*)('\))/g</span>, <span class="string">`$1当前版本<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span>$3`</span> )</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>常用排序算法快速排序、选择排序、堆排序。</p>
<h4 id="Fisher-Yates-shuffle算法"><a href="#Fisher-Yates-shuffle算法" class="headerlink" title="Fisher-Yates shuffle算法"></a>Fisher-Yates shuffle算法</h4><p>该算法是用来打乱数组的顺序。<br>简单来说就是从左往右循环数组的每个项，每次把当前项和当前项之后的项（包括当前项）随机选择一个进行交换，但是如果随机到自己则不进行交换。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shuffle(array)&#123;</span><br><span class="line">  <span class="comment">//最后一位只能选到自己，自己和自己不交换，所以最后一位就不考虑，所以把数组的长度减去1。</span></span><br><span class="line">  <span class="keyword">const</span> endIndex = array.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= endIndex; i++)&#123;</span><br><span class="line">      <span class="comment">//从当前位置之后（包括当前位置）随机取一个值进行交换。</span></span><br><span class="line">      <span class="keyword">const</span> j = i + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (array.length - i));</span><br><span class="line">      <span class="comment">//es6解构赋值</span></span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="shuffle算法.jpg"></p>
<h4 id="九宫格"><a href="#九宫格" class="headerlink" title="九宫格"></a>九宫格</h4><p>行坐标<code>colIndex</code>列坐标<code>rowIndex</code>和宫序号<code>boxIndex</code>宫内序号<code>cellIndex</code>的互相转换<br>宫坐标（Gx,Gy）。宫坐标的规律是，Gx是横坐标每3格＋1,Gy是纵坐标每3格＋1，所以要(col,row)转换成(Gx,Gy)就是把col和row分别/3取整，表示间隔了几次3格，得到的值就是（Gx,Gy）。((col/3),（row/3）)<br>宫序号boxIndex。我们把每个九宫格看成是一格，可以得出Gx每＋1就代表多1个九宫格，Gy每＋1就代表多3个九宫格。所以要计算宫序号，只要Gx＋Gy×3得到的值就是序号。(col/3)＋（row/3）×3<br>宫内格坐标。每3×3=9格是一个九宫格，图中总共有9个九宫格，然后每个九宫格都有自己的坐标从(0,0)-(2,2)。简单来说就是每隔3格，单元格的坐标就要重新计算。也就是说行列坐标对3求余表示当前的坐标遇3归0后剩下的值就是单元格的坐标。((colIndex%3),(rowIndex%3))<br>宫内序号cellIndex。每个九宫格都是一个独立的数组，要把九宫格里面的坐标转换成序号也是类似的。横坐标＋1表示单元格序号＋1，纵坐标+1表示单元格的序号+3。(colIndex%3)＋(rowIndex%3)×3</p>
<p>宫序号和宫内序号转换成行列坐标<br>因为Gx=col/3,Gy=row/3；所以col=Gx×3，row=Gy×3；(Gx×3,Gy×3)只是这个宫的左上角的坐标。根据宫内序号cellIndex可以得到cellIndex%3是宫内横坐标，cellIndex/3是宫内纵坐标。把宫内序号cellIndex代入可得((Gx×3＋cellIndex%3),(Gy×3＋cellIndex/3))。接下来根据宫序号boxIndex可以得到boxIndex%3是横坐标Gx，boxIndex/3是纵坐标Gy。最终用宫序号和宫内序号表示坐标。((boxIndex%3×3＋cellIndex%3),(boxIndex/3×3＋cellIndex/3))<br><img src="九宫格.png"></p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>XSS基本概念。跨站脚本攻击。跨站脚本攻击Cross Site Scripting<br>XSS原理。不需要登录认证，在提交区注入脚本，在合法的页面注入js。通过合法的途径输入不合法的内容。<br>XSS防范措施。过滤特殊字段，转义特殊字符。转义输入内容，过滤敏感字符</p>
<p>CSRF基本概念。跨站请求伪造。跨站请求伪造Cross-site request forgery<br>CSRF原理。登录A网站保存了cookie，访问B网站引诱用户点击发起了请求A网站的接口。用户登录过后拿到用户的cookie然后伪造用户的请求。<br>CSRF防范措施。token验证（服务器下发的token，自动请求的接口不会带token，而且token一般没办法伪造）、referer验证（验证来源是不是A网站）、隐藏令牌（放在head头中）增加token验证。</p>
<h4 id="XSS-漏洞的发生和修复"><a href="#XSS-漏洞的发生和修复" class="headerlink" title="XSS 漏洞的发生和修复"></a>XSS 漏洞的发生和修复</h4><p>通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示。<br>攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。<br>攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。<br>通过 HTML 转义，可以防止 XSS 攻击。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&lt;%= getParameter("</span><span class="attr">keyword</span>") %&gt;</span>"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：<span class="tag">&lt;<span class="name">%=</span> <span class="attr">getParameter</span>("<span class="attr">keyword</span>") %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当浏览器请求 <code>http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>时，服务端会解析出请求参数 keyword，得到 <code>&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'XSS'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是："&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'XSS'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>浏览器无法分辨出 <code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 是恶意代码，因而将其执行。这里不仅仅 div 的内容被注入了，而且 input 的 value 属性也被注入， alert 会弹出两次。</p>
<p>解决办法<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&lt;%= escapeHTML(getParameter("</span><span class="attr">keyword</span>")) %&gt;</span>"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：<span class="tag">&lt;<span class="name">%=</span> <span class="attr">escapeHTML</span>(<span class="attr">getParameter</span>("<span class="attr">keyword</span>")) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>escapeHTML() 按照如下规则进行转义：|字符|转义后的字符| |-|-| |&amp;|&amp;| |&lt;|&lt;| |&gt;|&gt;| |”|&quot;| |’|&#x27;| |/|&#x2F;|经过了转义函数的处理后，最终浏览器接收到的响应为<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>);<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#x2F;</span>script<span class="symbol">&amp;gt;</span>"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>);<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#x2F;</span>script<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>恶意代码都被转义，不再被浏览器执行，而且搜索词能够完美的在页面显示出来。</p>
<p>注意特殊的 HTML 属性、JavaScript API<br>做了 HTML 转义，并不等于高枕无忧。<br>对于链接跳转，如 &lt;a href=”xxx” 或 location.href=”xxx”，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= escapeHTML(getParameter("</span><span class="attr">redirect_to</span>")) %&gt;</span>"&gt;跳转...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码，当攻击 URL 为 <a href="http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)，服务端响应就成了：" target="_blank" rel="noopener">http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)，服务端响应就成了：</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>)"</span>&gt;</span>跳转...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据项目情况进行过滤，禁止掉 "javascript:" 链接、非法 scheme 等</span></span><br><span class="line">allowSchemes = [<span class="string">"http"</span>, <span class="string">"https"</span>];</span><br><span class="line">valid = isValid(getParameter(<span class="string">"redirect_to"</span>), allowSchemes);</span><br><span class="line"><span class="keyword">if</span> (valid) &#123;</span><br><span class="line">  &lt;a href=<span class="string">"&lt;%= escapeHTML(getParameter("</span>redirect_to<span class="string">"))%&gt;"</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&#125; else &#123;</span></span><br><span class="line"><span class="regexp">  &lt;a href="/</span><span class="number">404</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    跳转...</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>根据上下文采用不同的转义规则<br>HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。<br>应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。</p>
<p>漏洞总结<br>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。<br>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。<br>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。<br>在标签的 href、src 等属性中，包含 javascript: 等可执行代码。<br>在 onload、onerror、onclick 等事件中，注入不受控制代码。<br>在 style 属性和标签中，包含类似 background-image:url(“javascript:…”); 的代码（新版本浏览器已经可以防范）。<br>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（新版本浏览器已经可以防范）。<br>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</p>
<h4 id="React中对XSS如何进行XSS攻击和防范"><a href="#React中对XSS如何进行XSS攻击和防范" class="headerlink" title="React中对XSS如何进行XSS攻击和防范"></a>React中对XSS如何进行XSS攻击和防范</h4><p>prerender / SSR 的 hydrate 过程会生成 html ，需要小心测试其中是否有 XSS 漏洞。<br>dangerouslySetInnerHTML、onload=字符串、href=字符串 等，都有可能造成 XSS 漏洞。<br>所有的用户输入都需要经过HTML实体编码，这里React已经帮我们做了很多，它会在运行时动态创建DOM节点然后填入文本内容（你也可以强制设置HTML内容，不过这样比较危险）。<br>当你打算序列化某些状态并且传给客户端的时候，你同样需要进行HTML实体编码。<br>Yahoo的工程师已经提供了一个Serialize JavaScript模块帮我们轻松地进行JSON转码与过滤，我们可以直接使用npm install –save serialize-javascript导入该模块，然后使用serialize方法替代内置的JSON.stringify方法。</p>
<h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><p>async/await 和 promise<br>async/await 在底层转换成了 promise 和 then 回调函数。也就是说，这是 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。<br>async/await不要乱用，否则会增加没必要的时间浪费。比如原来可以并行执行的两个方法，使用了await就导致时间边长了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如原来b和d是可以并发执行的</span></span><br><span class="line">a(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;);</span><br><span class="line">c(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  d();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 但是这样await之后</span></span><br><span class="line"><span class="keyword">await</span> a();</span><br><span class="line"><span class="keyword">await</span> b();</span><br><span class="line"><span class="keyword">await</span> c();</span><br><span class="line"><span class="keyword">await</span> d();</span><br><span class="line"><span class="comment">// 就变成了顺序执行，增加了时间</span></span><br><span class="line">a(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  b(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    c(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      d();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>Karma 测试框架，提供多浏览器环境跑单元测试的能力，包括headless浏览器。<br>Mocha 测试框架，提供兼容浏览器和Node环境的单元测试能力，可使用karma-mocha集成进Karma中。<br>Chai 断言库，支持should,expect,assert不同类型的断言测试函数，可使用karma-chai集成进Karma中。<br>大部分单元测试都是基于上述三个库联合使用而展开的。Karma-webpack主要提供的能力，是为Karma中加载的测试脚本提供模块化加载的能力。</p>
<h3 id="数据库同步，升级indexDB"><a href="#数据库同步，升级indexDB" class="headerlink" title="数据库同步，升级indexDB"></a>数据库同步，升级indexDB</h3><p>参考svn的同步机制，是否已同步syncFlag，true已同步，false未同步。version比较。<br>syncFlag false<br>客户端版本 &gt; 服务端版本，不存在。<br>客户端版本 = 服务端版本，push数据。<br>客户端版本 &lt; 服务端版本，数据冲突。<br>syncFlag true<br>客户端版本 &gt; 服务端版本，不存在。<br>客户端版本 = 服务端版本，不操作。<br>客户端版本 &lt; 服务端版本，pull数据。</p>
<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><p>页面布局<br>几种布局方式。float，position，flex，table，grid<br>css盒子模型<br>标准盒子模型box-sizing:content-box<br>IE盒子模型box-sizing:border-box<br>DOM事件<br>事件捕获从上往下<br>事件冒泡从下往上</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>string , number , boolean , undefined , null , symbol<br>变量提升。js编译的时候把变量和函数提升到顶部。</p>
<h3 id="HTTP协议类"><a href="#HTTP协议类" class="headerlink" title="HTTP协议类"></a>HTTP协议类</h3><p>HTTP1.0/HTTP1.1<br>HTTP协议的主要特点。简单：快速uri唯一；灵活：可以完成不同数据类型的传输；无连接：连接一次就断掉，不会保持链接；无状态：服务端不保存客户端请求的状态。<br>HTTP报文的组成部分。请求报文：请求行（http方法，页面地址，协议，版本1.1），请求头（key value值），空行（分隔请求头和请求体），请求体；响应报文：状态行，响应头，空行，响应体。<br>HTTP方法。GET获取资源，POST传输资源，PUT更新资源，DELETE删除资源，HEAD获得报文首部，OPTION预请求一次能成功才接着往下。<br>POST和GET的区别。GET回退无害，POST会再次请求。GET请求会被浏览器主动缓存POST不行。GET请求参数会被完整的保留在浏览器历史里面POST不会，预防CSRF可以把GET改成POST。GET长度有限制2kb不同浏览器不一样。GET比较不安全参数直接放在url里面，POST放在body里面。<br>HTTP状态码。1xx指示信息，2xx成功，3xxurl已被重定向、缓存，4xx客户端错误参数错误、授权过期、不允许访问、不支持方法，5xx服务端错误内部错误、无效响应。<br>什么是持久连接。1.1支持1.0不支持keep-alive模式，持续有效，避免重新建立连接。<br>什么是管线化。在持久连接的前提request1，request2，request3一并发送，然后服务端返回response1，response2，response3</p>
<p>HTTP2.0<br>特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。<br>二进制传输：在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。首部信息会被封装到Headers帧，而Request Body则封装到Data帧<br>多路复用：在一个TCP连接中存在多个流，即可以同时发送多个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。我们原来针对这种场景做的优化是用雪碧图，这样图片只要加载一次，但是用多路复用则是根本上解决问题，直接一次发送多个请求，返回一次返回多个请求。<br>Header压缩：HTTP1的Header信息没有压缩每次都需要几百~几千字节。HTTP2用HPACK压缩算法，减小header的大小，记录header并维护索引表，下次再传输只要找到对应的索引就可以，不用重复传递太多的额外信息。<br>服务端push。<br>更安全。使用了tls的拓展ALPN做为协议升级，禁用不安全的算法。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>类与实例。类的声明。生成实例。<br>类与继承。如何实现继承，继承的几种方式。<br>call(this)或者apply(this)。缺点是只继承部分属性，如果父类有属性变化，子类并不会自动继承下来。<br>把原型对象指向父类的实例。<br>Child.prototype = new Parent()。parentName属性在子类找不到就去<strong>proto</strong>去找，而<strong>proto</strong>指向了prototype，所以就找到了父类的parentName。<br>缺点是c1=new child();c2=new child()。修改c1和c2的属性会指向同一个对象。这是因为prototype共用了一个对象。这种方法要特别注意prototype不要指向同一个对象。<br>组合继承。object.create()</p>
<h3 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h3><p>什么是同源策略及限制。协议，域名，端口要一致。不能操作cookie，localstorage，indexDB。DOM无法获得。AJAX请求不能发送跨域。<br>前后端如何通信。ajax，WebSocket不限制同源策略，CORS支持跨域和同源<br>如何创建ajax。XMLHttpRequest，ActiveXObject，构造data到url或者body里面，对返回的状态码处理。<br>跨域通信的几种方式。<br>JSONP。我在客户端定义了cb1函数，发送jsonp请求返回相应的数据给cb1，执行cb1。<br>Hash。window.location.onHashChange()，会获得所有的整个url。<br>PostMessage。A发送postMesage(‘data’,url)，B接收window.addEventListener(‘message’,function)<br>WebSocket。new WebSocket(url)。emit提交、onopen、onmessage监听、onclose，客户端和服务端通过emit和onmessage实现通讯。<br>CORS。fetch后.then.catch</p>
<h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><p>什么是DOCTYPE及作用。文档类型定义。html5<code>&lt;!DOCTYPE html&gt;</code> html4。告诉浏览器是什么文档类型，然后浏览器使用不懂的引擎渲染。<br>浏览器渲染过程。DOM tree + CSS tree =&gt; Render Tree =&gt; layout计算整个dom的宽高位置等全部的信息 =&gt; painting =&gt; display<br>重排reflow。本质上改变了盒子模型。一般导致reflow就会导致repaint。增加删除修改dom。通过css修改dom。修改字体。<br>重绘repaint。盒子模型没变但是里面的颜色变了。<br>布局layout。</p>
<h3 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h3><p>资源压缩合并，减少HTTP请求<br>非核心代码异步加载-&gt;异步加载的方式-&gt;异步加载的区别<br>动态脚本加载<br>defer。Html解析之后才执行，按顺序执行。<br>async。加载js后立即执行，不按顺序执行。<br>利用浏览器缓存-&gt;缓存的分类-&gt;缓存的原理<br>强缓存。在有效时间内直接从缓存拿出。<br>Header Expire：Thr，21 Jan 2017是绝对时间，服务器时间。 Cache-Control：max-age=3600相对时间，两个都有以这个为准。<br>协商缓存。把最后修改时间传递给服务器，确认后是否需要从缓存拿出。Etag If-None-Match If-Modified-Since<br>Last-Modified:wed,26 jan 2017<br>使用CDN<br>预解析DNS</p>
<h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p>即时运行错误<br>try catch<br>window.onerror<br>资源加载错误。不会冒泡。<br>object.onerror<br>performance.getEntries()，获取所有已加载的资源。<br>Error事件捕获，window.addEventLinster(‘error’,()=&gt;{console.log(1)},true)// ture捕获，false冒泡。<br>上报方式<br>ajax<br>(new Image()).src=’xxxx’。可以允许跨域。<br>allow-origin</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>n200 OK，当GET请求成功完成，DELETE或者PATCH请求同步完成。<br>n201 Created，对于那些要服务器创建对象的请求来说，资源已创建完毕。<br>n202 Accepted，POST，DELETE或者PATCH请求提交成功，稍后将异步的进行处理。<br>n204 No Content，Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）<br>n304 Not Modified，客户的缓存资源是最新的， 要客户端使用缓存<br>n400 Bad Request<br>  require_argument 缺少参数<br>  invalid_argument 无效参数<br>n401 Unauthorized: 请求失败，因为用户没有进行认证<br>  auth_token_expired 授权已过期<br>  auth_invalid_token 无效的授权(如token不存在、需要mac签名、mac签名无效、nonce无效、重复提交等)<br>n403 Forbidden: 请求失败，因为用户被认定没有访问特定资源的权限<br>  auth_denied 授权受限（无权限或IP地址受限等）<br>n405 Method Not Allowed：不支持该 Request 的方法<br>n406 Not Acceptable：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>n415 Unsupported Media Type: 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。<br>n429 Too Many Requests: 请求频率超配，稍后再试。<br>n500 Internal Server Error: 服务器遇到一个错误，使其无法为请求提供服务<br>n501 Not Implemented：客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。<br>n502 Bad Gateway：代理使用的服务器遇到了上游的无效响应<br>n503 Service Unavailable：服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</p>
<h3 id="mvvm框架"><a href="#mvvm框架" class="headerlink" title="mvvm框架"></a>mvvm框架</h3><p>MVC：model，view，controller。controller控制model如何在view显示。model和view对controller的数据流向都是单向的，从controller到model和view。<br>MVVM，model，view，ViewModel。ViewModel双向View，model通过ajax等方式修改viewModel。弱化了controller的存在。<br>双向绑定<br>正向。通过模板把数据放到模板中freemarker。<br>反向。view的改变反应到data中。<br>绑定。自动处理。Object.defineProperty。<br>生命周期<br>为什么说componentWillMount、componentWillReceive、componentWillUpdate不安全<br>引入的getDerivedStateFromProps、getSnapshotBeforeUpdate有什么作用<br>static getDerivedStateFromProps(nextProps, prevState)<br>静态方法，新props和当前state，返回的对象用来更新state，返回 null 则不更新任何内容。<br>在React v16.3时setState和forceUpdate不会触发该方法，据说是失误后来修复了。也就是说最新版本的：props改变，setState，forceUpdate都会触发该方法getDerivedStateFromProps。<br>getDerivedStateFromProps 的存在只有一个目的：让组件在 props 变化时更新 state。可以完美的解决willreceive的问题。<br>getSnapshotBeforeUpdate() 被调用于render之后componentDidUpdate之前，return的值会传入到componentDidUpdate里面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="literal">false</span>,</span><br><span class="line">    lastRow: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.currentRow !== prevState.lastRow) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isScrollingDown:</span><br><span class="line">            nextProps.currentRow &gt; prevState.lastRow,</span><br><span class="line">            lastRow: nextProps.currentRow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">//我们是否要添加新的 items 到列表?</span></span><br><span class="line">    <span class="comment">// 捕捉滚动位置，以便我们可以稍后调整滚动.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">//如果我们有snapshot值, 我们已经添加了 新的items.</span></span><br><span class="line">    <span class="comment">// 调整滚动以至于这些新的items 不会将旧items推出视图。</span></span><br><span class="line">    <span class="comment">// (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="lifecycle.png"><br><img src="lifecycle1.jpg"><br><img src="lifecycle2.jpg"></p>
<h3 id="React源码"><a href="#React源码" class="headerlink" title="React源码"></a>React源码</h3><p>extends。继承了ReactComponent<br>component的render。render其实就是调用React.createElement方法。该方法返回一个ReactElement对象，即组件对象。<br>ReactDOM.render(component,mountNode).</p>
<h3 id="servier-worker"><a href="#servier-worker" class="headerlink" title="servier worker"></a>servier worker</h3><h3 id="pwa"><a href="#pwa" class="headerlink" title="pwa"></a>pwa</h3>
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/前端基础/" rel="tag"># 前端基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2017/11/03/blog/front-end-performance/front-end-performance/" rel="next" title="前端性能优化">
                <i class="fa fa-chevron-left"></i> 前端性能优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/01/03/blog/git/git/" rel="prev" title="Git">
                Git <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大大白</p>
              <p class="site-description motion-element" itemprop="description">沉淀下来的东西，才是真正属于自己的财富！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/blog/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/blog/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React"><span class="nav-number">1.</span> <span class="nav-text">React</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Router"><span class="nav-number">1.1.</span> <span class="nav-text">React Router</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redux-Saga"><span class="nav-number">1.2.</span> <span class="nav-text">Redux Saga</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React性能优化"><span class="nav-number">1.3.</span> <span class="nav-text">React性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合理使用Container和Dump"><span class="nav-number">1.3.1.</span> <span class="nav-text">合理使用Container和Dump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#针对React的diff算法加入key，防止最坏情况的发生"><span class="nav-number">1.3.2.</span> <span class="nav-text">针对React的diff算法加入key，防止最坏情况的发生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。"><span class="nav-number">1.3.3.</span> <span class="nav-text">尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Webpack"><span class="nav-number">2.</span> <span class="nav-text">Webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#性能优化"><span class="nav-number">2.1.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loader"><span class="nav-number">2.2.</span> <span class="nav-text">Loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他配置"><span class="nav-number">2.3.</span> <span class="nav-text">其他配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node"><span class="nav-number">3.</span> <span class="nav-text">Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Babel"><span class="nav-number">4.</span> <span class="nav-text">Babel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#presets打包优化"><span class="nav-number">4.1.</span> <span class="nav-text">presets打包优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#plugins"><span class="nav-number">4.2.</span> <span class="nav-text">plugins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#babel在webpack中出现的问题"><span class="nav-number">4.3.</span> <span class="nav-text">babel在webpack中出现的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eslint"><span class="nav-number">5.</span> <span class="nav-text">Eslint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Immutable"><span class="nav-number">6.</span> <span class="nav-text">Immutable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本规范state-set-‘key’-value"><span class="nav-number">6.1.</span> <span class="nav-text">基本规范state.set(‘key’,value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">7.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本流程"><span class="nav-number">7.1.</span> <span class="nav-text">基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#劫持"><span class="nav-number">7.2.</span> <span class="nav-text">劫持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字证书"><span class="nav-number">7.3.</span> <span class="nav-text">数字证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全传输证书"><span class="nav-number">7.4.</span> <span class="nav-text">安全传输证书</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS基础"><span class="nav-number">8.</span> <span class="nav-text">JS基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型与原型链"><span class="nav-number">8.1.</span> <span class="nav-text">原型与原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域及闭包"><span class="nav-number">8.2.</span> <span class="nav-text">作用域及闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步和单线程"><span class="nav-number">8.3.</span> <span class="nav-text">异步和单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前置知识"><span class="nav-number">8.3.1.</span> <span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务队列"><span class="nav-number">8.3.2.</span> <span class="nav-text">任务队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行过程"><span class="nav-number">8.3.3.</span> <span class="nav-text">执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#开始执行"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">开始执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局Script代码执行完了，进入下一个步骤，从microtask-queue中依次取出任务执行，直到microtask-queue队列为空。"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">9.1.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法"><span class="nav-number">9.2.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fisher-Yates-shuffle算法"><span class="nav-number">9.2.1.</span> <span class="nav-text">Fisher-Yates shuffle算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九宫格"><span class="nav-number">9.2.2.</span> <span class="nav-text">九宫格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全"><span class="nav-number">9.3.</span> <span class="nav-text">安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-number">9.3.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XSS-漏洞的发生和修复"><span class="nav-number">9.3.2.</span> <span class="nav-text">XSS 漏洞的发生和修复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#React中对XSS如何进行XSS攻击和防范"><span class="nav-number">9.3.3.</span> <span class="nav-text">React中对XSS如何进行XSS攻击和防范</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES7"><span class="nav-number">9.4.</span> <span class="nav-text">ES7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单元测试"><span class="nav-number">9.5.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库同步，升级indexDB"><span class="nav-number">9.6.</span> <span class="nav-text">数据库同步，升级indexDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础部分"><span class="nav-number">9.7.</span> <span class="nav-text">基础部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">9.8.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP协议类"><span class="nav-number">9.9.</span> <span class="nav-text">HTTP协议类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">9.10.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信类"><span class="nav-number">9.11.</span> <span class="nav-text">通信类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染机制"><span class="nav-number">9.12.</span> <span class="nav-text">渲染机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面性能"><span class="nav-number">9.13.</span> <span class="nav-text">页面性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误监控"><span class="nav-number">9.14.</span> <span class="nav-text">错误监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态码"><span class="nav-number">9.15.</span> <span class="nav-text">状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mvvm框架"><span class="nav-number">9.16.</span> <span class="nav-text">mvvm框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React源码"><span class="nav-number">9.17.</span> <span class="nav-text">React源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#servier-worker"><span class="nav-number">9.18.</span> <span class="nav-text">servier worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwa"><span class="nav-number">9.19.</span> <span class="nav-text">pwa</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大大白</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/blog/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/blog/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
